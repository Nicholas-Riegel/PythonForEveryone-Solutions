2

==================================
VARIABLES, EXPRESSIONS, STATEMENTS
==================================

** power

operator precedence

parenthesis
power
multiplication/division left to right
addition/subtraction left to right

type() finds what type sth is, eg. string, number

type conversions

float(9) == 9.0
int('1') == 1

python3 division is always float

to get user input

x = input('What is your name: ')
x == yoyo
print('Welcome', x) # Welcome yoyo

comment #

3

============
CONDITIONALS
============ 

indentation should be four spaces
indentation indicates dependency

x = 4
if x > 2:
    print('bigger')
else:
    print('smaller')
print('all done')

............ 

# no else
x = 5
if x < 2:
    print('small')
elif x < 10:
    print('medium')

this just means that it won't print, if x >=10

try/except

surround dangerous code with a try block,
if the code fails it jumps to the except
otherwise the except is skipped

x = 'hello world'
try:
    y = int(x)
except:
    y = -1
print('first', y)

x = '123'
try:
    y = int(x)
except:
    y = -1
print('second', y)

4

=========
FUNCTIONS
=========

def  #define FUNCTIONS

def thing():
    print('thing')


def stores and names the following code

built in functions:
print()
int()
str()
float()
type()
input()

math module: 'import math'
math.log10()
math.pi
math.sin()
math.sqrt()

random module: 'import random'
random.random() #betw 0 inclusive and 1 exclusive
random.randint(0, 10) #rand int betw 
t = [1, 2, 3]
ramdom.choice(t)


max() #finds the biggest character in a string?
min() # finds the smallest

return # ends function and returns the value


def do(x)
    return x + 2

x # parameter 
x + 2 # result
do(3) # 3 is argument

>>> print_twice('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam

The argument is evaluated before the function is called.

You can also use a variable as an argument: 

>>> michael = 'Eric, the half a bee.'
>>> print_twice(michael)
Eric, the half a bee.
Eric, the half a bee. 

The name of the variable we pass as an argument (michael) has nothing to do with the name of the parameter (bruce). It doesn't matter what the value was called back home (in the caller); here in print_twice, we call everybody bruce.

Void functions might display something on the screen or have some other effect, but they don't have a return value. If you try to assign the result to a variable, you get a special value called None. 

>>> result = print_twice('Bing')
Bing
Bing
>>> print(result)
None

To return a result from a function, we use the return statement in our function. For example, we could make a very simple function called addtwo that adds two numbers together and returns a result. 

def addtwo(a, b):
    added = a + b
    return added

x = addtwo(3, 5)
print(x)

5

==========
ITERATIONS
==========

INDEFINITE LOOPS 

while True:
    line = input('> ')
    if line[0] == # :
        continue         
    if line == 'done' :
        break
    print(line)
print('Done!')


> hello
hello
> # don't print this
> print this
print this
> done
Done!

'continue' stops the prgress, and sends back to beginning
'break' breaks out of the loop

this are indefinte loops
they go on indefintely 

DEFINITE LOOPS

use 'for' keyword
iterate through the members of a set

y = [1, 2, 3, 4, 5]
for x in y:
    print(x)

1
2
3
4
5
...............
sum()
adds all members of a list
.............

'None' is a type
it is a value, signifies emptiness
'is' is stronger than ==

smallest = None
for x in [9, 41, 12, 3, 74, 15]:
    if smallest is None:
        smallest = x
    elif x < smallest:
        smallest = x
    pirnt(smallest, x)
print(smallest)

'is' are these things equal in type and value
== are these things equal in value

only use 'is/is not' on booleans and noneTypes (<= recommended)

6

=======
STRINGS
======= 

STRINGS: looping through them

'len' finds length of string
len('abc') # 3
x = 'abc'
x[1] # b

fruit[-1] yields the last letter, fruit[-2] yields the second to last, and so on.

Strings are immutable
the best you can do is create a new string
>>> greeting = 'Hello, world!'
>>> new_greeting = 'J' + greeting[1:]
>>> print(new_greeting)
Jello, world!

fruit = 'banana'
i = 0
while i < len(fruit):
    letter = fruit[i]
    print(i, letter)
    i += 1

0b
1a
2n
3a
4n
5a

Slicing

s = 'Monty Python'
print(s[0:5]) # Monty
print 0 up to but not including 5

print(s[6:20]) # is ok, it will stop at the end

print(s[:1]) # M    
print(s[6:]) # Python
print(s[:]) # Monty Python

fruit = 'banana'
'n' in fruit # true
'm' in fruit # false

can use comparison operators on STRINGS
to aphabetize

'alpha' < 'beta' # true

String Libaray

'dir' lists methods available on an object
strings are objects

>>> help(str.capitalize)
Help on method_descriptor:

capitalize(...)
    S.capitalize() -> str

    Return a capitalized version of S, i.e.

 
Methods
method of string-object

greet = 'Hello Bob'
zap = greet.lower()
print(zap) # hello bob

print('Hi There'.lower()) # hi there [!!]

stuff = 'hello'
dir(stuff) # shows all the methods of the string constant

str.find('na')
returns position of first
or returns -1 if not found

str.upper()

but str remains unchanged

>>> line = 'Have a nice day'
>>> line.startswith('h')
False
>>> line.lower()
'have a nice day'
>>> line.lower().startswith('h')
True

greet = 'hello Bob'
x = greet.replace('Bob', 'Jane')
print(x) # Hello Jane

y = greet.replace('o', 'x')
print(y) # Hellx Bxb

greet = ' hello bob '
greet.lstrip() # 'hello bob '
greet.rstrip() # ' hello bob'
greet.strip() # 'hello bob'

this also gets rid of tabs or newlines

Prefixes

line = 'Please have a nice day'
line.startswith('Please') # true
line.startswith('p') # false

Parsing and extracting:

data = "from stephen.marquard@uct.ac.za Sat"
atpos = data.find('@') # 21
sppos = data.find(' ', atpos) 31
finds the space after atpos
host = data[atpos+1 : sppos] # uct.ac.za

Formatting

>>> 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'

7

=====
FILES
=====

open()

finds the file and returns a handle

handle = open(filename, mode)

f = open('file.txt', 'r')

r - read
w - write

f is not the file
so print(f) will only show some metadata about the file

\n - the 'newline' character. it's one character, not two

len(x\ny) == 3

There's an '\n' at the end of each line in a file

FILES AS A SEQUENCE

We can read files as a sequence of lines
this means we can use the 'for in' structure

f = open('file.txt')
for x in f:
    print(x)

counting lines:

f = open('file.txt')
count = 0
for x in f:
    count += 1
print('Line count:', count)

Reading the whole file:  read()

f = open('file.txt')
x = f.read()
print(len(x))
9462
print(x[:2])
ab

It is a good idea to store the output of read as a variable because each call to read exhausts the resource: >>> fhand = open('mbox-short.txt')
>>> print(len(fhand.read()))
94626
>>> print(len(fhand.read()))
0

Searching throught a file:

f = open('file.txt')
for x in f:
    if x.startswith('From:') :
        print(x)

this will print out with line in between every line.

this is bc another \n is added by all print statements

to deal with this, you can 'right strip' the \n, because it is considered a 'white space'

f = open('file.txt')
for x in f:
    x = x.rstrip()
    if x.startswith('From:') :
        print(x)

Skipping with 'continue':

'if not'

f = open('file.txt')
for x in f:
    x = x.rstrip()
    if not x.startswith('From:')
        continue
    print(x)

Using find():

fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    if line.find('@uct.ac.za') == -1:
        continue
    print(line)

Using 'in' to select lines:

f = open('file.txt')
for x in f:
    x = x.rstrip()
    if not '@uct.ac.za' in x:
        continue
    print(x)

Prompt for file name:

fname = input('Enter file name: ')
fhand = open(fname)
count = 0
for x in fhand:
    if x.startswith('Subject:') :
        count += 1
print('There were', count, 'subject lines in', fname)

Bad file names:

fname = input('Enter file name: ')

try:
    fhand = open(fname)
except:
    print('File not found:', fname)
    quit()

count = 0
for x in fhand:
    if x.startswith('Subject:') :
        count += 1
print('There were', count, 'subject lines in', fname)

Writing files:

To write a file, you have to open it with mode "w" as a second parameter: 

>>> fout = open('output.txt', 'w')
>>> print(fout)
<_io.TextIOWrapper name='output.txt' mode='w' encoding='cp1252'> 

IF THE FILE ALREADY EXISTS, OPENING IT IN WRITE MODE CLEARS OUT THE OLD DATA AND STARTS FRESH, SO BE CAREFUL! IF THE FILE DOESN'T EXIST, A NEW ONE IS CREATED."

The write method of the file handle object puts data into the file, returning the number of characters written. The default write mode is text for writing (and reading) strings. 

>>> line1 = "This here's the wattle,\n"
>>> fout.write(line1)
24

Again, the file object keeps track of where it is, so if you call write again, it adds the new data to the end. 

We must make sure to manage the ends of lines as we write to the file by explicitly inserting the newline character when we want to end a line. The print statement automatically appends a newline, but the write method does not add the newline automatically. 

>>> line2 = 'the emblem of our land.\n'
>>> fout.write(line2)
24 

When you are done writing, you have to close the file to make sure that the last bit of data is physically written to the disk so it will not be lost if the power goes off. >>> fout.close()

Debugging:

newlines etc. are normally invisible: 

>>> s = '1 2\t 3\n 4'
>>> print(s)
1 2  3
 4 

'repr' can help. 

>>> print(repr(s))
'1 2\t 3\n 4' 

8

=====
LISTS
=====

lists are data-structures

strings are immutable
fruit = 'banana'
fruit[0] = 'c' # traceback

lists are mutable

The in operator also works on lists. >>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> 'Edam' in cheeses
True
>>> 'Brie' in cheeses
False

range(4) # [0, 1, 2, 3]

returns a list with numbers up to one less than parameter (but parameter number)

list = ['a', 'b', 'c']
print(len(list)) # 3
print(range(len(list))) # [0, 1, 2]

friends = ['Joseph', 'Glenn', 'Sally']

for friend in friends:
    print('happy New year:', friend)

for i in range(len(friends))
    friend = friends[i]
    print('happy New year:', friend)

Happy new year: joseph
Happy new year: Glenn
Happy new year: Sally

LISTS 2:

concatenating lists

a = [1, 2, 3]
b = [4, 5, 6]
c = a + b 
[1, 2, 3, 4, 5, 6]

Similarly, the * operator repeats a list a given number of times: >>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]

slicing works the same way as with strings

[2:3]
will only give you the '2' position

up to but not including

A slice operator on the left side of an assignment can update multiple elements: 

>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3] = ['x', 'y']
>>> print(t)
['a', 'x', 'y', 'd', 'e', 'f']

x = list()
type(x)
<type 'list'>
dir(x)
['append', 'count', etc. ]

stuff = list()
stuff.append('book')
stuff.append(9) // adds to end

extend takes a list as an argument and appends all of the elements: >>> t1 = ['a', 'b', 'c']
>>> t2 = ['d', 'e']
>>> t1.extend(t2)
>>> print(t1)
['a', 'b', 'c', 'd', 'e'] This example leaves t2 unmodified.

sort arranges the elements of the list from low to high: >>> t = ['d', 'c', 'e', 'b', 'a']
>>> t.sort()
>>> print(t)
['a', 'b', 'c', 'd', 'e']

Most list methods are void; they modify the list and return None. If you accidentally write t = t.sort(), you will be disappointed with the result.


friends.sort() // sorts alphabetically

The 'in' operator:

'boo' in stuff
True
20 not in stuff
True

Deleting elements: 

>>> t = ['a', 'b', 'c']
>>> x = t.pop(1)
>>> print(t)
['a', 'c']
>>> print(x)

b pop modifies the list and returns the element that was removed. If you don't provide an index, it deletes and returns the last element. If you don't need the removed value, you can use the del operator: 

>>> t = ['a', 'b', 'c']
>>> del t[1]
>>> print(t)
['a', 'c']

>>> t = ['a', 'b', 'c']
>>> t.remove('b')
>>> print(t)
['a', 'c'] The return value from remove is None.

Built in functions

nums = [3, 41, 12, 9, 74, 15]
len(nums)
6
max(nums)
74
min(nums)
3
sum(nums)
154
sum(nums)/len(nums)
25.6

LISTS AND STRINGS

string. To convert from a string to a list of characters, you can use list: >>> s = 'spam'
>>> t = list(s)
>>> print(t)
['s', 'p', 'a', 'm']

x = 'with three words'
list = x.split() // no delimiter: splits on white spaces
['with', 'three', 'words']

split() cuts out the spaces, no matter how many there are

thing = 'first;second;third'
thing.split(';') // spcifying the delimiter
['first', 'second', 'third']

join is the inverse of split. It takes a list of strings and concatenates the elements. join is a string method, so you have to invoke it on the delimiter and pass the list as a parameter: >>> t = ['pining', 'for', 'the', 'fjords']
>>> delimiter = ' '
>>> delimiter.join(t)
'pining for the fjords'

Parsing Lines:

fhand = open('mbox-short.txt')
for line in fhand:
    line = ling.rstrip() //takes off \n
    if not line.startswith('From '): continue
    list = line.split()
    print(list[2])

pieces = email.split('@')
['dfhgh', 'asdfasfd.com']

Objects and Values:

To check whether two variables refer to the same object, you can use the is operator. 

>>> a = 'banana'
>>> b = 'banana'
>>> a is b
True 

In this example, Python only created one string object, and both a and b refer to it. But when you create two lists, you get two objects: 

>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False

In this case we would say that the two lists are equivalent, because they have the same elements, but not identical, because they are not the same object. If two objects are identical, they are also equivalent, but if they are equivalent, they are not necessarily identical. Until now, we have been using "object" and "value" interchangeably, but it is more precise to say that an object has a value. If you execute a = [1,2,3],a refers to a list object whose value is a particular sequence of elements. If another list has the same elements, we would say it has the same value.

It is important to distinguish between operations that modify lists and operations that create new lists. For example, the append method modifies a list, but the + operator creates a new list: >>> t1 = [1, 2]
>>> t2 = t1.append(3)
>>> print(t1)
[1, 2, 3]
>>> print(t2)
None

>>> t3 = t1 + [3]
>>> print(t3)
[1, 2, 3]
>>> t2 is t3
False

9

============
DICTIONARIES
============

dict1 = dict()
{}

dict1['one'] = 'uno'
{
    'one': 'uno'
}

>>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
>>> print(eng2sp)
{'one': 'uno', 'three': 'tres', 'two': 'dos'}

order is changed; properties are not found by order

dict1['two']
'dos'

len() returns number of key value pairs

in - use in to find keys in a dict

>>> 'one' in eng2sp
True
>>> 'uno' in eng2sp
False 

values() - To see whether something appears as a value in a dictionary, you can use the method 'values()', which returns the values as a list, and then use the in operator: 

>>> vals = list(eng2sp.values())
>>> 'uno' in vals
True
...............

dict = dict()
names = ['csev', 'cwen', 'csev', 'zqian', 'cwen']

for x in names:
    if x not in dict :
        dict[x] = 1
    else :
        dict[x] = dict[x] + 1
print(dict)

.................

get()

if name in dict:
    val = dict[name]
else:
    val = 0

||

val = dict.get(name, 0)

................

dict = dict()
names = ['csev', 'cwen', 'csev', 'zqian', 'cwen']

for x in names:
    dict[x] = dict.get(x, 0) + 1

print(dict)

...........

Definite Loops and Dictionaries

dict = { 'chuck':1, 'fred':42, 'jan':100}
for x in dict:
    print(x, dict[x])

jan 100
chuck 1
fred 42

..............
Dictionary Methods

dict = { 'chuck':1, 'fred':42, 'jan':100}
print(list(dict))
['jan', 'chuck', 'fred']

print(dict.keys())
['jan', 'chuck', 'fred']

print(dict.values())
[100, 1, 42]

print(dict.items())
[('jan', 100), ('chuck', 1), ('fred', 42)]

a list of tuples

...............
Two iteration variables

dict = { 'chuck':1, 'fred':42, 'jan':100}

for a, b in dict.items():
    print(a, b)

jan 100
chick 1
fred 42
...........

Advanced text parsing:

how to deal iwth punctuation and capitalization?

We can solve both these problems by using the string methods lower, punctuation, and translate. The translate is the most subtle of the methods. Here is the documentation for translate: 

line.translate(str.maketrans(fromstr, tostr, deletestr))

Replace the characters in fromstr with the character in the same position in tostr and delete all characters that are in deletestr. The fromstr and tostr can be empty strings and the deletestr parameter can be omitted.

We will not specify the tostr but we will use the deletestr parameter to delete all of the punctuation. We will even let Python tell us the list of characters that it considers "punctuation": 

>>> import string
>>> string.punctuation
'!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~' 

We make the following modifications to our program: import string

fname = input('Enter the file name: ')

try:
    fhand = open(fname)
except:
    print('File cannot be opened:', fname)
    exit()

counts = dict()

for line in fhand:
    line = line.rstrip()
    line = line.translate(line.maketrans('', '', string.punctuation))
    line = line.lower()
    words = line.split()
    for word in words:
        if word not in counts:
            counts[word] = 1
        else:
            counts[word] += 1

print(counts)


10

======
TUPLES
======

immutable versions of lists

more efficient, lightweight

Syntactically, a tuple is a comma-separated list of values: 

>>> t = 'a', 'b', 'c', 'd', 'e' 

Although it is not necessary, it is common to enclose tuples in parentheses to help us quickly identify tuples when we look at Python code: 

>>> t = ('a', 'b', 'c', 'd', 'e') 

To create a tuple with a single element, you have to include the final comma: 

>>> t1 = ('a',)
>>> type(t1)
<type 'tuple'>

Create a tuple:

x = tuple()

If the argument is a sequence (string, list, or tuple), the result of the call to tuple is a tuple with the elements of the sequence: 

>>> t = tuple('lupins')
>>> print(t)
('l', 'u', 'p', 'i', 'n', 's')

>>> t = ('a', 'b', 'c', 'd', 'e')
>>> print(t[0])
'a'

And the slice operator selects a range of elements. >>> print(t[1:3])
('b', 'c')

You can't modify the elements of a tuple, but you can replace one tuple with another: 

>>> t = ('A',) + t[1:]
>>> print(t)
('A', 'b', 'c', 'd', 'e')

Assignment statements

(x, y) = (4, 'fred')
print(y)
'fred'
print(x)
4

For example, to split an email address into a user name and a domain, you could write: 

>>> addr = 'monty@python.org'
>>> uname, domain = addr.split('@')

Tuples and Dictionaries

d = dict()
d['csev'] = 2
d['cwen'] = 4
for (k,v) in d.items():
    print(k, v)
csev 2
cwen 4

tups = d.items()
print(tups)
dict_items([('csev', 2), ('cwen', 4)])

Comparing Tuples:

Zero index is most significant
if they are the same, then it goes on to next

>>> (0, 1, 2) < (0, 3, 4)
True
>>> (0, 1, 2000000) < (0, 3, 4)
True
>>> ('Jones', 'Sally') < ('Jones', 'Sam')
true
>>> ('Jones', 'Sally') > ('Adams', 'Sam')
true

Sorting lists of tuples:

d = {'a': 10, 'b':1, 'c':22}
d.items()
dict_items([('a', 10), ('c', 22), ('b', 1)])
sorted(d.items())
[('a', 10), ('b', 1), ('c', 22)]
sorts based on key

Using sorted()

d = {'a': 10, 'b':1, 'c':22}
t = sorted(d.items())
t
[('a', 10), ('b', 1), ('c', 22)]
for k,v in sorted(d.items()):
    print(k,v)
a 10
b 1
c 22

For example, suppose you have a list of words and you want to sort them from longest to shortest: 

txt = 'but soft what light in yonder window breaks'
words = txt.split()
t = list()
for x in words:
    t.append( (len(x), x) )

 print(t)
 [(3, 'but'), (4, 'soft'), (4, 'what'), (5, 'light'), (2, 'in'), (6, 'yonder'), (6, 'window'), (6, 'breaks')]

t.sort(reverse=True)

res = list()
for a, b in t:
    res.append(b)

print(res)
['yonder', 'window', 'breaks', 'light', 'what',
'soft', 'but', 'in']

Putting a dictionary into a list of tuples:

>>> d = {'a':10, 'b':1, 'c':22}
>>> l = list()
>>> for key, val in d.items() :
...     l.append( (val, key) )
...
>>> l
[(10, 'a'), (22, 'c'), (1, 'b')]


Sorting by values instead of key:

c= {'a': 10, 'c':22, 'b':1 }
tmp = list()
for k, v in c.items():
    tmp.append( (v, k) )
#this puts the value first
print(tmp)
[(10, 'a'), (22, 'c'), (1, 'b')]
tmp = sorted(tmp)
print(tmp)
[(1, 'b'), (10, 'a'), (22, 'c')]

tmp = sorted(tmp, reverse=True)
print(tmp)
[(22, 'c'), (10, 'a'), (1, 'b')]


Top ten most common words

import string
fhand = open('romeo.txt')
dict = dict()
for line in dict:
    words = line.split()
    for word in words:
        dict[word] = dict.get(word, 0) +1

list = list()
for k, v in dict.items():
    list.append( (v,k) )

list = sorted(list, reverse=True)

for v, k in list[:10]:
    print(k, v)

Shorter 'lambda' version

c = {'a': 10, 'c':22, 'b':1 }
x = sorted( [ (v,k) for k,v in c.items() ] )
#this says make a list where each element is of form (v, k) 'for' the following 
print(x)
[(1, 'b'), (10, 'a'), (22, 'c')]

From the book:

import string
fhand = open('romeo-full.txt')
counts = dict()
for line in fhand:
line = line.translate(str.maketrans('', '', string.punctuation))
    line = line.lower()
    words = line.split()
    for word in words:
        if word not in counts:
            counts[word] = 1
        else:
            counts[word] += 1

# Sort the dictionary by value
lst = list()
for key, val in list(counts.items()):
    lst.append((val, key))

lst.sort(reverse=True)

for key, val in lst[:10]:
    print(key, val)
