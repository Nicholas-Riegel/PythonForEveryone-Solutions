2

==================================
VARIABLES, EXPRESSIONS, STATEMENTS
==================================

** power

operator precedence

parenthesis
power
multiplication/division left to right
addition/subtraction left to right

type() finds what type sth is, eg. string, number

type conversions

float(9) == 9.0
int('1') == 1

python3 division is always float

to get user input

x = input('What is your name: ')
x == yoyo
print('Welcome', x) # Welcome yoyo

comment #

3

============
CONDITIONALS
============ 

indentation should be four spaces
indentation indicates dependency

x = 4
if x > 2:
    print('bigger')
else:
    print('smaller')
print('all done')

............ 

# no else
x = 5
if x < 2:
    print('small')
elif x < 10:
    print('medium')

this just means that it won't print, if x >=10

try/except

surround dangerous code with a try block,
if the code fails it jumps to the except
otherwise the except is skipped

x = 'hello world'
try:
    y = int(x)
except:
    y = -1
print('first', y)

x = '123'
try:
    y = int(x)
except:
    y = -1
print('second', y)

4

=========
FUNCTIONS
=========

def  #define FUNCTIONS

def thing():
    print('thing')


def stores and names the following code

built in functions:
print()
int()
str()
float()
type()
input()

math module: 'import math'
math.log10()
math.pi
math.sin()
math.sqrt()

random module: 'import random'
random.random() #betw 0 inclusive and 1 exclusive
random.randint(0, 10) #rand int betw 
t = [1, 2, 3]
ramdom.choice(t)


max() #finds the biggest character in a string?
min() # finds the smallest

return # ends function and returns the value


def do(x)
    return x + 2

x # parameter 
x + 2 # result
do(3) # 3 is argument

>>> print_twice('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam

The argument is evaluated before the function is called.

You can also use a variable as an argument: 

>>> michael = 'Eric, the half a bee.'
>>> print_twice(michael)
Eric, the half a bee.
Eric, the half a bee. 

The name of the variable we pass as an argument (michael) has nothing to do with the name of the parameter (bruce). It doesn't matter what the value was called back home (in the caller); here in print_twice, we call everybody bruce.

Void functions might display something on the screen or have some other effect, but they don't have a return value. If you try to assign the result to a variable, you get a special value called None. 

>>> result = print_twice('Bing')
Bing
Bing
>>> print(result)
None

To return a result from a function, we use the return statement in our function. For example, we could make a very simple function called addtwo that adds two numbers together and returns a result. 

def addtwo(a, b):
    added = a + b
    return added

x = addtwo(3, 5)
print(x)

5

==========
ITERATIONS
==========

INDEFINITE LOOPS 

while True:
    line = input('> ')
    if line[0] == # :
        continue         
    if line == 'done' :
        break
    print(line)
print('Done!')


> hello
hello
> # don't print this
> print this
print this
> done
Done!

'continue' stops the prgress, and sends back to beginning
'break' breaks out of the loop

this are indefinte loops
they go on indefintely 

DEFINITE LOOPS

use 'for' keyword
iterate through the members of a set

y = [1, 2, 3, 4, 5]
for x in y:
    print(x)

1
2
3
4
5
...............
sum()
adds all members of a list
.............

'None' is a type
it is a value, signifies emptiness
'is' is stronger than ==

smallest = None
for x in [9, 41, 12, 3, 74, 15]:
    if smallest is None:
        smallest = x
    elif x < smallest:
        smallest = x
    pirnt(smallest, x)
print(smallest)

'is' are these things equal in type and value
== are these things equal in value

only use 'is/is not' on booleans and noneTypes (<= recommended)

6

=======
STRINGS
======= 

STRINGS: looping through them

'len' finds length of string
len('abc') # 3
x = 'abc'
x[1] # b

fruit[-1] yields the last letter, fruit[-2] yields the second to last, and so on.

Strings are immutable
the best you can do is create a new string
>>> greeting = 'Hello, world!'
>>> new_greeting = 'J' + greeting[1:]
>>> print(new_greeting)
Jello, world!

fruit = 'banana'
i = 0
while i < len(fruit):
    letter = fruit[i]
    print(i, letter)
    i += 1

0b
1a
2n
3a
4n
5a

Slicing

s = 'Monty Python'
print(s[0:5]) # Monty
print 0 up to but not including 5

print(s[6:20]) # is ok, it will stop at the end

print(s[:1]) # M    
print(s[6:]) # Python
print(s[:]) # Monty Python

fruit = 'banana'
'n' in fruit # true
'm' in fruit # false

can use comparison operators on STRINGS
to aphabetize

'alpha' < 'beta' # true

String Libaray

'dir' lists methods available on an object
strings are objects

>>> help(str.capitalize)
Help on method_descriptor:

capitalize(...)
    S.capitalize() -> str

    Return a capitalized version of S, i.e.

 
Methods
method of string-object

greet = 'Hello Bob'
zap = greet.lower()
print(zap) # hello bob

print('Hi There'.lower()) # hi there [!!]

stuff = 'hello'
dir(stuff) # shows all the methods of the string constant

str.find('na')
returns position of first
or returns -1 if not found

str.upper()

but str remains unchanged

>>> line = 'Have a nice day'
>>> line.startswith('h')
False
>>> line.lower()
'have a nice day'
>>> line.lower().startswith('h')
True

greet = 'hello Bob'
x = greet.replace('Bob', 'Jane')
print(x) # Hello Jane

y = greet.replace('o', 'x')
print(y) # Hellx Bxb

greet = ' hello bob '
greet.lstrip() # 'hello bob '
greet.rstrip() # ' hello bob'
greet.strip() # 'hello bob'

this also gets rid of tabs or newlines

Prefixes

line = 'Please have a nice day'
line.startswith('Please') # true
line.startswith('p') # false

Parsing and extracting:

data = "from stephen.marquard@uct.ac.za Sat"
atpos = data.find('@') # 21
sppos = data.find(' ', atpos) 31
finds the space after atpos
host = data[atpos+1 : sppos] # uct.ac.za

Formatting

>>> 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'

7

=====
FILES
=====

open()

finds the file and returns a handle

handle = open(filename, mode)

f = open('file.txt', 'r')

r - read
w - write

f is not the file
so print(f) will only show some metadata about the file

\n - the 'newline' character. it's one character, not two

len(x\ny) == 3

There's an '\n' at the end of each line in a file

FILES AS A SEQUENCE

We can read files as a sequence of lines
this means we can use the 'for in' structure

f = open('file.txt')
for x in f:
    print(x)

counting lines:

f = open('file.txt')
count = 0
for x in f:
    count += 1
print('Line count:', count)

Reading the whole file:  read()

f = open('file.txt')
x = f.read()
print(len(x))
9462
print(x[:2])
ab

Searching throught a file:

f = open('file.txt')
for x in f:
    if x.startswith('From:') :
        print(x)

this will print out with line in between every line.

this is bc another \n is added by all print statements

to deal with this, you can 'right strip' the \n, because it is considered a 'white space'

f = open('file.txt')
for x in f:
    x = x.rstrip()
    if x.startswith('From:') :
        print(x)

Skipping with 'continue':

'if not'

f = open('file.txt')
for x in f:
    x = x.rstrip()
    if not x.startswith('From:')
        continue
    print(x)

Using 'in' to select lines:

f = open('file.txt')
for x in f:
    x = x.rstrip()
    if not '@uct.ac.za' in x:
        continue
    print(x)

Prompt for file name:

fname = input('Enter file name: ')
fhand = open(fname)
count = 0
for x in fhand:
    if x.startswith('Subject:') :
        count += 1
print('There were', count, 'subject lines in', fname)

Bad file names:

fname = input('Enter file name: ')

try:
    fhand = open(fname)
except:
    print('File not found:', fname)
    quit()

count = 0
for x in fhand:
    if x.startswith('Subject:') :
        count += 1
print('There were', count, 'subject lines in', fname)

8

=====
LISTS
=====

lists are data-structures

strings are immutable
fruit = 'banana'
fruit[0] = 'c' # traceback

lists are mutable

range(4) # [0, 1, 2, 3]

returns a list with numbers up to one less than parameter (but parameter number)

list = ['a', 'b', 'c']
print(len(list)) # 3
print(range(len(list))) # [0, 1, 2]

friends = ['Joseph', 'Glenn', 'Sally']

for friend in friends:
    print('happy New year:', friend)

for i in range(len(friends))
    friend = friends[i]
    print('happy New year:', friend)

Happy new year: joseph
Happy new year: Glenn
Happy new year: Sally

LISTS 2:

concatenating lists

a = [1, 2, 3]
b = [4, 5, 6]
c = a + b 
[1, 2, 3, 4, 5, 6]

slicing works the same way as with strings

[2:3]
will only give you the '2' position

up to but not including

x = list()
type(x)
<type 'list'>
dir(x)
['append', 'count', etc. ]

stuff = list()
stuff.append('book')
stuff.append(9) // adds to end

The 'in' operator:

'boo' in stuff
True
20 not in stuff
True

friends.sort() // sorts alphabetically

Built in functions

nums = [3, 41, 12, 9, 74, 15]
len(nums)
6
max(nums)
74
min(nums)
3
sum(nums)
154
sum(nums)/len(nums)
25.6

LISTS AND STRINGS

x = 'with three words'
list = x.split() // no delimiter: splits on white spaces
['with', 'three', 'words']

split() cuts out the spaces, no matter how many there are

thing = 'first;second;third'
thing.split(';') // spcifying the delimiter
['first', 'second', 'third']

fhand = open('mbox-short.txt')
for line in fhand:
    line = ling.rstrip() //takes off \n
    if not line.startswith('From '): continue
    list = line.split()
    print(list[2])

pieces = email.split('@')
['dfhgh', 'asdfasfd.com']

9

============
DICTIONARIES
============

dict1 = dict()
{}

dict1['one'] = 'uno'
{
    'one': 'uno'
}

>>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
>>> print(eng2sp)
{'one': 'uno', 'three': 'tres', 'two': 'dos'}

order is changed; properties are not found by order

dict1['two']
'dos'

len() returns number of key value pairs

in - use in to find keys in a dict

>>> 'one' in eng2sp
True
>>> 'uno' in eng2sp
False 

values() - To see whether something appears as a value in a dictionary, you can use the method 'values()', which returns the values as a list, and then use the in operator: 

>>> vals = list(eng2sp.values())
>>> 'uno' in vals
True
...............

dict = dict()
names = ['csev', 'cwen', 'csev', 'zqian', 'cwen']

for x in names:
    if x not in dict :
        dict[x] = 1
    else :
        dict[x] = dict[x] + 1
print(dict)

.................

get()

if name in dict:
    val = dict[name]
else:
    val = 0

||

val = dict.get(name, 0)

................

dict = dict()
names = ['csev', 'cwen', 'csev', 'zqian', 'cwen']

for x in names:
    dict[x] = dict.get(x, 0) + 1

print(dict)

...........

Definite Loops and Dictionaries

dict = { 'chuck':1, 'fred':42, 'jan':100}
for x in dict:
    print(x, dict[x])

jan 100
chuck 1
fred 42

..............
Dictionary Methods

dict = { 'chuck':1, 'fred':42, 'jan':100}
print(list(dict))
['jan', 'chuck', 'fred']

print(dict.keys())
['jan', 'chuck', 'fred']

print(dict.values())
[100, 1, 42]

print(dict.items())
[('jan', 100), ('chuck', 1), ('fred', 42)]

a list of tuples

...............
Two iteration variables

dict = { 'chuck':1, 'fred':42, 'jan':100}

for a, b in dict.items():
    print(a, b)

jan 100
chick 1
fred 42

